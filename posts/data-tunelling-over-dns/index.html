<!DOCTYPE html>
<html prefix="
og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Data tunelling over DNS | Povilas Blog</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="http://blog.povilasb.com/posts/data-tunelling-over-dns/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Povilas Balciunas">
<link rel="prev" href="../linux-network-routing-table/" title="Linux network routing table" type="text/html">
<link rel="next" href="../silence-does-not-mean-stagnation/" title="Silence does not mean stagnation" type="text/html">
<meta property="og:site_name" content="Povilas Blog">
<meta property="og:title" content="Data tunelling over DNS">
<meta property="og:url" content="http://blog.povilasb.com/posts/data-tunelling-over-dns/">
<meta property="og:description" content="Some public Wi-Fi spots have internet access restricted until you authenticate
yourself. This quite often happens in airports and hotels.
One interesting thing about such network setups is that DNS is">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-10-12T19:35:24+03:00">
<meta property="article:tag" content="dns">
<meta property="article:tag" content="networking">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark
bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="../../">

            <span id="blog-title">Povilas Blog</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../../archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="../../categories/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../../rss.xml" class="nav-link">RSS feed</a>

                
            </li>
</ul>
<ul class="navbar-nav navbar-right">
<li class="nav-item">
    <a href="index.rst" id="sourcelink" class="nav-link">Source</a>
    </li>

                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Data tunelling over DNS</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Povilas Balciunas
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2017-10-12T19:35:24+03:00" itemprop="datePublished" title="2017-10-12 19:35">2017-10-12 19:35</time></a>
            </p>
                <p class="commentline">    

                    </p>
<p class="sourceline"><a href="index.rst" class="sourcelink">Source</a></p>

        </div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Some public Wi-Fi spots have internet access restricted until you authenticate
yourself. This quite often happens in airports and hotels.
One interesting thing about such network setups is that DNS is working.
This fact can be exploited to tunnel arbitrary data through DNS
requests/responses.</p>
<p>In a nutshell the process looks like this:</p>
<pre class="literal-block">                   +-----------+
                   | DNS query |
+--------+    1    |           |
| Client | ------&gt; | +------+  |
+--------+         | | Data |  |
    ^              | +------+  |
    |              +-----------+
    |                   |
    | 6                 | 2
    |                   v
    |             +--------------+
    +------------ | DNS Resolver | --------------+
                  |    @ISP      |        3      |
                  +--------------+               |
                         ^                       |
                       5 |                       |
                         |                       V
                  +--------------+        +------------+
                  | DNS response |        | DNS server |
                  |              |        +------------+
                  |   +------+   |               |
                  |   | Data |   | &lt;-------------+
                  |   +------+   |         4
                  +--------------+</pre>
<ol class="arabic simple">
<li><p>Client encodes his data into DNS query.</p></li>
<li><p>DNS query is sent to DNS resolver which usually is at <a class="reference external" href="https://en.wikipedia.org/wiki/Internet_service_provider">ISP</a>.</p></li>
<li><p>DNS resolver sends request to DNS server <a class="footnote-reference brackets" href="#footnote-1" id="footnote-reference-1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. This DNS server is our software
which is capable of decoding data from DNS query.</p></li>
<li><p>Our DNS server encodes some arbitrary data to DNS response.</p></li>
<li><p>Response is sent back to DNS resolver.</p></li>
<li><p>Resolver relays the response to client which then can decode the data
inside DNS response.</p></li>
</ol>
<section id="setup"><h2>Setup</h2>
<p>The existing DNS ecosystem will tunnel our data. But we need to control
DNS server which decodes our requests and sends responses back.
Thus we need 4 things:</p>
<ol class="arabic simple">
<li><p>control over a real domain,</p></li>
<li><p>NS record pointing to our server,</p></li>
<li><p>a server with UDP port 53 open,</p></li>
<li><p>software handling DNS requests.</p></li>
</ol>
<p>I own <cite>povilasb.com</cite> domain thus I can delegate a subdomain for my DNS server:</p>
<pre class="literal-block">ns.povilasb.com        A       86.100.203.141

$ host ns.povilasb.com
ns.povilasb.com has address 86.100.203.141</pre>
<p>Then to route all queries for <cite>tun.povilasb.com</cite> subdomains to <cite>ns.povilasb.com</cite>
server NS record is required:</p>
<pre class="literal-block">tun.povilasb.com       NS      ns.povilasb.com</pre>
<p>Finally, a simple Python script is sufficient to receive DNS requests:</p>
<div class="code"><pre class="code python"><a id="rest_code_8692e16a0af7420eb581b8e52080ba99-1" name="rest_code_8692e16a0af7420eb581b8e52080ba99-1" href="#rest_code_8692e16a0af7420eb581b8e52080ba99-1"></a><span class="kn">import</span> <span class="nn">socket</span>
<a id="rest_code_8692e16a0af7420eb581b8e52080ba99-2" name="rest_code_8692e16a0af7420eb581b8e52080ba99-2" href="#rest_code_8692e16a0af7420eb581b8e52080ba99-2"></a>
<a id="rest_code_8692e16a0af7420eb581b8e52080ba99-3" name="rest_code_8692e16a0af7420eb581b8e52080ba99-3" href="#rest_code_8692e16a0af7420eb581b8e52080ba99-3"></a><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span><span class="p">)</span>
<a id="rest_code_8692e16a0af7420eb581b8e52080ba99-4" name="rest_code_8692e16a0af7420eb581b8e52080ba99-4" href="#rest_code_8692e16a0af7420eb581b8e52080ba99-4"></a><span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">'0.0.0.0'</span><span class="p">,</span> <span class="mi">53</span><span class="p">))</span>
<a id="rest_code_8692e16a0af7420eb581b8e52080ba99-5" name="rest_code_8692e16a0af7420eb581b8e52080ba99-5" href="#rest_code_8692e16a0af7420eb581b8e52080ba99-5"></a><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<a id="rest_code_8692e16a0af7420eb581b8e52080ba99-6" name="rest_code_8692e16a0af7420eb581b8e52080ba99-6" href="#rest_code_8692e16a0af7420eb581b8e52080ba99-6"></a>    <span class="n">request</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span>
<a id="rest_code_8692e16a0af7420eb581b8e52080ba99-7" name="rest_code_8692e16a0af7420eb581b8e52080ba99-7" href="#rest_code_8692e16a0af7420eb581b8e52080ba99-7"></a>    <span class="nb">print</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span>
</pre></div>
<p>The script must be run the script with root permissions:</p>
<pre class="literal-block">$ sudo python3 main.py</pre>
<p>Now we can test if server works by sending DNS requests from any computer:</p>
<pre class="literal-block">$ host abc.tun.povilasb.com</pre>
<p>Python script should write received buffer to stdout:</p>
<pre class="literal-block">sudo python3 main.py
('212.59.18.8', 64329) b'Y\xbd\x00\x00\x00\x01\x00\x00\x00\x00\x00\x01\x03abc\x03tun\x08povilasb\x03com\x00\x00\x01\x00\x01\x00\x00)\x10\x00\x00\x00\x80\x00\x00\x00'</pre>
<p>If you can see such output, it means that you set up DNS records correctly.
Now we can replace this small Python script with one that is capable of
encoding/decoding data to DNS requests and responses.</p>
</section><section id="data-encoding"><h2>Data encoding</h2>
<p>We can implement bidirectional communication on top of DNS:</p>
<pre class="literal-block">+--------+   request     +------------+
| Client | ------------&gt; | DNS Server |
+--------+               +------------+
    ^                          |
    |        response          |
    +--------------------------+</pre>
<p>Request and response are encoded in different ways and must be handled
separately.</p>
<p>Some sample Python code can be found at <a class="reference external" href="https://github.com/povilasb/iptun/blob/5da201661474b5a3e0fb898f2c445929cb2a5233/iptun/dns.py">https://github.com/povilasb/iptun/blob/5da201661474b5a3e0fb898f2c445929cb2a5233/iptun/dns.py</a>.
And if you want to see a full working DNS tunneling server, check
<a class="reference external" href="https://github.com/yarrick/iodine">https://github.com/yarrick/iodine</a>. Although, it's a C based project which is
more difficult to read.</p>
<section id="upstream"><h3>Upstream</h3>
<p>As funny as it sounds we can encode data to domain name. E.g. DNS query with
record <cite>thisismydata.tun.example.com</cite> carries "thisismydata" string which can
be anything.
We can even encode binary data this way using Base64 encoding:</p>
<pre class="literal-block">dGhpc2lzbXlkYXRhIC1uCg==.tun.example.com</pre>
<p>Unfortunately, DNS names have some limitations which we have to respect
if we want our queries to be delivered <a class="footnote-reference brackets" href="#footnote-2" id="footnote-reference-2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>:</p>
<pre class="literal-block"> max 255 bytes
 _____________
|             |
v             V
label.name.com.
      ^  ^
      |__|

     max 63 bytes</pre>
<ol class="arabic simple">
<li><p>maximum total DNS name length is 255 bytes,</p></li>
<li><p>every substring separated by dot must not exceed 63 bytes.</p></li>
</ol>
<p>So if you have data encoded to Base64 which exceeds 63 bytes, it must
be split into multiple parts:</p>
<p><cite>dmVyeSBsb25nIHRleHQgZXhjZWVkaW5nIDYzIGJ5dGVzLCBleGNlZWRpbmcgNjMgYnl0ZXMK</cite> is
encoded to
<cite>dmVyeSBsb25nIHRleHQgZXhjZWVkaW5nIDYzIGJ5dGVzLCBleGNlZWRpbmcgNjM.gYnl0ZXMK.tun.example.com</cite>.</p>
<p>Note that if you query for the same domain name twice, the query will not be
delivered to our DNS server, instead cache will be used.
Thus I add some random nonce to every domain name:</p>
<pre class="literal-block">data.a2.example.com
data.m4.example.com</pre>
</section><section id="downstream"><h3>Downstream</h3>
<p>When encoding data to DNS response multiple record types can be used: NULL,
PRIVATE, TXT, SRV, MX, CNAME and A records. <a class="footnote-reference brackets" href="#footnote-3" id="footnote-reference-3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>
The record type is selected in DNS query.</p>
<p>I know for a fact that TXT and NULL records allow arbitrary data to be attached.
Thus you encode your data inside TXT record and send it back to the client.
Then in Wireshark the DNS response looks like this:</p>
<img alt="/images/dns_txt_resp.png" src="../../images/dns_txt_resp.png"><aside class="footnote-list brackets"><aside class="footnote brackets" id="footnote-1" role="note"><span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#footnote-reference-1">1</a><span class="fn-bracket">]</span></span>
<p>There's actually more steps involved until DNS Resolver knows the
DNS server it has to communicate with: <a class="reference external" href="https://howdns.works/ep1/">https://howdns.works/ep1/</a></p>
</aside><aside class="footnote brackets" id="footnote-2" role="note"><span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#footnote-reference-2">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.ietf.org/rfc/rfc1035.txt">https://www.ietf.org/rfc/rfc1035.txt</a></p>
</aside><aside class="footnote brackets" id="footnote-3" role="note"><span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#footnote-reference-3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/yarrick/iodine#operational-info">https://github.com/yarrick/iodine#operational-info</a></p>
</aside></aside></section></section>
</div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/dns/" rel="tag">dns</a></li>
            <li><a class="tag p-category" href="../../categories/networking/" rel="tag">networking</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../linux-network-routing-table/" rel="prev" title="Linux network routing table">Previous post</a>
            </li>
            <li class="next">
                <a href="../silence-does-not-mean-stagnation/" rel="next" title="Silence does not mean stagnation">Next post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
            

        </section></article><!--End of body content--><footer id="footer">
            Contents © 2022         <a href="mailto:balciunas90@gmail.com">Povilas Balciunas</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
</div>
</div>

        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
